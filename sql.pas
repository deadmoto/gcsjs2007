unit SQL;

interface

uses
  Windows,
  Messages,
  SysUtils,
  Variants,
  Classes,
  Graphics,
  Controls,
  Forms,
  Dialogs,
  StdCtrls,
  Grids,
  DBGrids,
  DB,
  DBTables,
//  FileCtrl,
  ComCtrls;

type
  TSQLExecForm = class(TForm)
    DBGrid1:     TDBGrid;
    SaveDialog1: TSaveDialog;
    OpenDialog1: TOpenDialog;
    TabControl1: TTabControl;
    GroupBox1:   TGroupBox;
    Memo1:       TMemo;
    Button1:     TButton;
    Button2:     TButton;
    Button4:     TButton;
    Button3:     TButton;
    Button5:     TButton;
    procedure Button1Click(Sender: TObject);
    procedure Button2Click(Sender: TObject);
    procedure Button4Click(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure FormShow(Sender: TObject);
    procedure Button3Click(Sender: TObject);
    procedure Button5Click(Sender: TObject);
    procedure TabControl1Change(Sender: TObject);
  private
    { Private declarations }
    path: string;//путь по умолчанию
  public
    { Public declarations }
  end;

var
  SQLExecForm: TSQLExecForm;

implementation

uses
  datamodule,
  main,
  service,
  dbf;

{$R *.dfm}

procedure TSQLExecForm.Button1Click(Sender: TObject);
{*******************************************************************************
  Процедура Button1Click выполняет запрос, который введен пользователем в Memo1.
  Если запрос пуст или содержит некоторую ошибку, то выдается предупреждение.
*******************************************************************************}
begin
  if Memo1.Lines.Count <> 0 then
    try
      with DModule.Query1 do
      begin
        Close;
        SQL.Text := Memo1.Text;

        case TabControl1.TabIndex of
          0:
          begin
            Open;
          end;
          1:
          begin
            ExecSQL;
            ShowMessage('Запрос выполнен');
          end;
        end;
      end;
    except
      DModule.Query1.Close;
      ShowMessage('Запрос содержит ошибку!');
    end
  else
    ShowMessage('Введите запрос!');
end;

procedure TSQLExecForm.Button2Click(Sender: TObject);
{*******************************************************************************
  Процедура Button2Click очищает Memo1 и стирает результат запроса.
********************************************************************************}
begin
  Memo1.Clear;
  DModule.Query1.Close;
end;

procedure TSQLExecForm.Button4Click(Sender: TObject);
{*******************************************************************************
  Процедура Button4Click совершает экспорт результата запроса в файл DBase 4.0
  untitled1.dbf с указанной кодировкой ANSI или OEM, по умолчанию ANSI.
  Если результат запроса нулевой, то экспорта не произойдет.
*******************************************************************************}
var
  i: integer;
begin
  SaveDialog1.Filter := 'dBase files(*.dbf)|*.dbf|Все файлы(*.*)|*.*';

  if not SaveDialog1.Execute then Exit;

  with DModule do
  begin
    if Dbf1.Active then
      Dbf1.Close;
    if not Query1.IsEmpty then
    begin
      //DBGrid1.DataSource := '';
      
      //создание таблицы
      for i := 0 to Query1.FieldCount - 1 do
        Dbf1.AddFieldDefs(GetName(Query1.Fields[i]), GetType(Query1.Fields[i]),
          GetSize(Query1.Fields[i]), GetPrec(Query1.Fields[i]));
      Dbf1.TableName := SaveDialog1.FileName;// path + 'untitled1.dbf';
      Dbf1.CreateTable;
      Dbf1.CodePage := Form1.codedbf;
      //запись в нее данных
      while not Query1.EOF do
      begin
        Dbf1.Append;
        for i := 1 to Query1.FieldCount do
          EditField(Query1.Fields[i - 1].AsString, DBF1.CodePage, i);
        Dbf1.Post;
        Query1.Next;
      end;
      Dbf1.Close;
      Query1.Close;
      //DBGrid1.DataSource := DataSource1;
    end
    else
      ShowMessage('Для экспорта в dbf необходим ненулевой результат запроса!');
  end;
end;

procedure TSQLExecForm.FormClose(Sender: TObject; var Action: TCloseAction);
{*******************************************************************************
  Процедура FormClose закрывает Query1, которые используются при работе
  в этом unit. Также устанавливается русская раскладка для ввода.
*******************************************************************************}
var
  rl, el: THandle;
  Layouts: array[0..7] of THandle;
  c, i: integer;
begin
  //русская расладка
  c := GetKeyboardLayoutList(High(Layouts) + 1, Layouts);
  for i := 0 to c - 1 do
  begin
    if LoWord(Layouts[i]) and $FF = Lang_Russian then
      rl := Layouts[i];
    if LoWord(Layouts[i]) and $FF = Lang_English then
      el := Layouts[i];
  end;
  if rl <> 0 then
    ActivateKeyboardLayout(rl, 0);
  DModule.Query1.Close;

  if not Assigned(Form1) then
  begin
    DModule.dbfConnection.Connected := False;
    DModule.DataBase1.Connected := False;
    Application.Terminate;
  end;
end;

procedure TSQLExecForm.FormShow(Sender: TObject);
{*******************************************************************************
  Процедура FormShow обрабатывает событие OnShow формы. Устанавливается английская
  раскладка для ввода запроса, путь по умолчанию, куда можно сохранять текст
  запроса и откуда его можно загрузить, а также путь к каталогу, в который сохраняется
  результат экспорта в dbf.
*******************************************************************************}
var
  rl, el: THandle;
  Layouts: array[0..7] of THandle;
  c, i: integer;
begin
  DModule.Query1.Close;
  //английская раскладка
  c := GetKeyboardLayoutList(High(Layouts) + 1, Layouts);
  for i := 0 to c - 1 do
  begin
    if LoWord(Layouts[i]) and $FF = Lang_Russian then
      rl := Layouts[i];
    if LoWord(Layouts[i]) and $FF = Lang_English then
      el := Layouts[i];
  end;
  if el <> 0 then
    ActivateKeyboardLayout(el, 0);
  path := ExtractFilePath(Application.ExeName) + 'querys\';
  OpenDialog1.InitialDir := path;
  SaveDialog1.InitialDir := path;
  path := ExtractFilePath(Application.ExeName) + 'out\';
end;

procedure TSQLExecForm.TabControl1Change(Sender: TObject);
begin
  case TabControl1.TabIndex of
    0:
    begin
      Button4.Visible := True;
    end;
    1:
    begin
      Button4.Visible := False;
    end;
  end;
end;

procedure TSQLExecForm.Button3Click(Sender: TObject);
{*******************************************************************************
  Процедура Button3Click сохраняет текст запроса в файл с именем, выбранным в
  появившемся диалоге.
*******************************************************************************}
begin
  SaveDialog1.Filter := 'Файлы запросов(*.sql)|*.sql|Текстовые файлы(*.txt)|*.txt|Все файлы(*.*)|*.*';
  if SaveDialog1.Execute then
    Memo1.Lines.SaveToFile(SaveDialog1.FileName);
end;

procedure TSQLExecForm.Button5Click(Sender: TObject);
{*******************************************************************************
  Процедура Button3Click загружает текст запроса из файл с именем, выбранным в
  появившемся диалоге.
*******************************************************************************}
begin
  if OpenDialog1.Execute then
    begin
      Memo1.Lines.LoadFromFile(OpenDialog1.FileName);
    end;
end;

end.
